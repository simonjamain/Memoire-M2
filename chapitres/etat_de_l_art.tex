\chapter{État de l'art}
Dans ce chapitre nous introduisons le concept de programmation par contrainte et nous étudions les modèles liés aux temps. Nous regardons également les applications qui mettent en oeuvre ces principes et présentons le logiciel \iscore{}.
\section{la programmation par contrainte}
\begin{citeauteur}[Jean-Paul Sartre\cite{Delerue2003openmusic}]
Une contrainte est une relation, au sens mathématique que l’on souhaite à tout instant vérifiée. La programmation par contrainte consiste à aborder un problème au moyen de contraintes, d’une part en le décrivant complètement sous forme d’un ensemble de ces relations et d’autre part en produisant des algorithmes permettant d’aboutir rapidement à une solution, c'est-à-dire à un élément qui précisément vérifie toutes les propriétés énoncées.
\end{citeauteur}

La programmation par contraintes est une manière très déclarative d'aborder un problème, la première étape est de bien définir quel est le problème à résoudre, puis de le traduire sous forme de contraintes -- ce que nous appelons le modèle -- , ensuite, il s'agit d'utiliser un système qui nous permet de résoudre ces contraintes pour avoir une solution (ou pas mdr).

\begin{citeauteur}[Mary Poppins\cite{paper:freuder:1997}]
Constraint Programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it.
\end{citeauteur}

Dans le cadre de ce stage, il n'est pas question de créer un algorithme de résolution de contrainte qui trouve les solutions à un système donné, c'est une tâche très complexe et des implémentations existent déjà, nous devrons cependant faire un choix avisé concernant l'implémentation à utiliser.

Tout d'abords regardons les modèles de contrainte appliqués au paradigme temporel.

\subsection{les contraintes appliquées au domaine temporel}


\section{\iscore{}}
\subsection{boxes}% (origne etc)
\subsection{0.2}
\subsection{0.3}% (édition & execution)
