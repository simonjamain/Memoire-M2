\chapter{Implémentations}
Dans cette partie, nous nous interessons à la mise en oeuvre technique des différents concept abordés. Tout d'abord, intéressons-nous à l'agencement des différentes briques logicielles qui composent \iscore{}.

\schema{archi}{figarchi}{Le CSP est utilisé par l'interface pour la configuration graphique ainsi que pour de la pré-validation, il est également utilisé par le moteur pour une étape de validation et de pré-processing.}

\section{API \ossia{}}
L'API \ossia{} est un ensemble de classes C++ représentant les différents éléments scénaristiques, les timenodes, les relations temporelles, etc... Elle permet aux différents organes d'\iscore{} de communiquer

\section{TDD}

\begin{wrapfigure}{r}{0.3\textwidth}
    \centering
    \illustrationKeepDim{niveauxTest}
    \caption{ Les différents niveaux des composants de l'application.\label{figNiveauTests}}
\end{wrapfigure}

J'utilise le \acrfull{tdd} dans ma méthode de développement, les tests écrit doivent permettre de vérifier le bon fonctionnement du solveur à l'exécution. On évitera ainsi la régression est on assurera la validité du système chaque mise à jour.

Les tests écrits couvrent le code en partant des fonctionnalités de bas niveau jusqu'aux fonctionnalités de haut niveau (cf. figure \ref{figNiveauTests}).

\emph{Comment valider le solveur?}
Nous nous intéresseront ici uniquement a la manière de tester du solveur. Par tester le solveur on entend prouver le fonctionnement du solveur, pour cela nous étudieront le système de contraintes d'un point de vue mathématique pour essayer de réduire les tests à des exemples minimaux.

\subsubsection{Propagation des contraintes}
Les deux opération de composition de base des contraintes sont la composition en parallèle et en série. À la manière des circuit électroniques, on montre que l'on peux toujours prendre deux points et calculer la contrainte équivalente.

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{preuve1}
    \caption{Composition en série de deux contraintes. \label{figSerie}}
\end{figure}
\setcounter{equation}{0}
Sachant deux timenodes \timeNode{1}~et \timeNode{2}~reliés ensemble par un contrainte \contrainte{1}, et un timenode \timeNode{3} relié à \timeNode{2} par une contrainte \contrainte{2} (cf. figure \ref{figSerie}), on a :
\begin{gather} 
    \timeNode{1} + \buteeMin{1} \leq \timeNode{2} \leq \timeNode{1} + \buteeMax{1}\\
    \timeNode{2} + \buteeMin{2} \leq \timeNode{3} \leq \timeNode{2} + \buteeMax{2}
\end{gather}
L'équation étant compatible avec l'addition, et grâce à la transitivité on peut écrire ceci : 
\begin{equation}
    \timeNode{1} + \buteeMin{1} + \timeNode{2} + \buteeMin{2} \leq \timeNode{2} + \timeNode{3} \leq \timeNode{1} + \buteeMax{1} +         \timeNode{2} + \buteeMax{2}
\end{equation} 
On supprime T2 :
\begin{equation}
    \timeNode{1} + \buteeMin{1} + \buteeMin{2} \leq + \timeNode{3} \leq \timeNode{1} + \buteeMax{1} + \buteeMax{2}
\end{equation}
On peut alors définir une contrainte \contrainte{3}~reliant \timeNode{1} à \timeNode{3} telle que : 

\begin{gather}
    \buteeMin{3} = \buteeMin{1} + \buteeMin{2}\\
    \buteeMax{3} = \buteeMax{1} + \buteeMax{2}\\
    \timeNode{1} + \buteeMin{3} \leq \timeNode{3} \leq \timeNode{1} + \buteeMax{3}
\end{gather}
\setcounter{equation}{0}

En répétant l'opération, on peut désormais réduire un enchaînement "horizontal" d'un nombre finit de contraintes à une seule.

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{preuve2}
    \caption{Composition en parallèle de deux contraintes. \label{figParallele}}
\end{figure}
Sachant deux timenodes \timeNode{1}~et \timeNode{2}~reliés ensemble par deux contraintes \contrainte{1}~et\contrainte{2} (cf. figure \ref{figParallele}), on a :
\begin{gather} 
    \timeNode{1} + \buteeMin{1} \leq \timeNode{2} \leq \timeNode{1} + \buteeMax{1}\\
    \timeNode{1} + \buteeMin{2} \leq \timeNode{2} \leq \timeNode{1} + \buteeMax{2}
\end{gather}
On décrit les fonctions min et max telles que : 
\begin{gather}
    \mathrm{min}(a,b) = \left\{\begin{matrix}
        a~\text{si}~a\leq b \\
        b~\text{sinon}
        \end{matrix}\right.\\
    \mathrm{max}(a,b) = \left\{\begin{matrix}
        a~\text{si}~a\geq b \\
        b~\text{sinon}
        \end{matrix}\right.
\end{gather}
Grâce à la transitivité, on peut alors écrire ceci :
\begin{equation}
    \begin{split}
        \timeNode{1} + \mathrm{min}(\buteeMin{1}, \buteeMin{2})\\
        &\quad \leq \timeNode{1} + \mathrm{max}(\buteeMin{1}, \buteeMin{2})\\
        &\quad \leq \timeNode{2}\\
        &\quad \leq \timeNode{1} + \mathrm{min}(\buteeMax{1}, \buteeMax{2})\\
        &\quad \leq \timeNode{1} + \mathrm{max}(\buteeMax{1}, \buteeMax{2})
    \end{split}
\end{equation} 
En retirant les variable inutiles, on obtient :
\begin{equation}
    \timeNode{1} + \mathrm{max}(\buteeMin{1}, \buteeMin{2}) \leq \timeNode{2} \leq \timeNode{1} + \mathrm{min}(\buteeMax{1}, \buteeMax{2})
\end{equation} 
On peut alors définir une contrainte \contrainte{3}~reliant \timeNode{1} à \timeNode{2} telle que :
\begin{gather}
    \buteeMin{3} = \mathrm{max}(\buteeMin{1}, \buteeMin{2})\\
    \buteeMax{3} = \mathrm{min}(\buteeMax{1}, \buteeMax{2})\\
    \timeNode{1} + \buteeMin{3} \leq \timeNode{2} \leq \timeNode{1} + \buteeMax{3}
\end{gather}

En répétant l'opération, on peut désormais réduire un nombre finit de combinaison de contraintes à une seule contrainte.

Par construction, un scénario et un enchaînement de contraintes combinée horizontalement ou verticalement, on peut alors se réduire à tester les combinaisons de deux contraintes.

et comme décrire les types de scénarios à tester sont fastidieux à exprimer avec des mots, je m'appuie sur une description graphique.
Certains cas sont impossible directement par la construction des contraintes :
\begin{itemize}
    \item Impossible de mettre une souplesse amont infinie;
    \item Impossible de mettre une durée nominale infinie;
    \item Impossible de mettre des valeurs négative pour les durées;
    \item Impossible d'avoir plusieurs Start;
    \item Impossible d'avoir une timenode sans contrainte à sa gauche, (sauf start).
\end{itemize}


\section{Algorithme de propagation}
On souhaite construire un algorithme efficace qui nous permet de répondre a notre problème :
Les données :
\begin{itemize}
\item des dates
\item des intervalles de temps entre des dates
\end{itemize}

La premiere question :
Les données :
\begin{itemize}
\item Les dates fournies peuvent-elles exister dans ces intervalles de temps ?
\item (Sinon quelles dates sont incohérentes ?)
\item Tous les intervalles de temps peuvent-il être respectés ?
\item (Sinon, quels intervalles en tords ?)
\end{itemize}

Dans un premier temps, nous essayons de propager les minimums et maximum. Pour orienter les recherches on s'inspirera d'un système mécanique.

\begin{algorithmic}

\IF {$i\geq 5$} 
        \STATE $i\gets i-1$
\ELSE
        \IF {$i\leq 3$}
                \STATE $i\gets i+2$
        \ENDIF
\ENDIF 
\end{algorithmic}

quand la date n'est pas fixée, Time

MIN :
si date
return date
sinon
min1 = Cprev.min + Tprev.min || Time
min2 = Tnext.min - Cnext.max || Time
return max(min1, min2)

MAX :
si date
date
sinon
max1 = Cprev.max + Tprev.max || infinity
max2 = Tnext.max - Cnext.min || infinity
return min(max1, max2)

