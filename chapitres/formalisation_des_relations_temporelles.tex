\chapter{Formalisation des relations temporelles}
Pour arriver à une solution, je dois d'abord définir précisément les objectifs, à savoir quel est le ou les rôle(s) attendu(s) du CSP.

Pour orienter les recherches, il est utile de partir sur une base bien définie. Or, le fonctionnement des contraintes et des interactions possibles n'est pas encore bien formalisé. Je vais donc tout d'abord expliciter le fonctionnement et le formaliser avec des règles qui seront la base de ma réflexion.

\section{Contraintes pour l'édition}

Pour créer/éditer des scénarios interactifs, nous utilisons les éléments suivants :

\begin{itemize}
    \item Les \textbf{\glspl{timenode}}, qui sont des points de synchronisations temporels ;
    \item Les \textbf{évènements}, ils sont placés sur des \glspl{timenode} et peuvent être déclenchés par une condition/action quand le \gls{timenode} et situé dans son intervalle de déclenchement. Quand un évènement est \emph{déclenché}, le \gls{timenode} est alors \emph{exécuté}, et vice versa\footnote{Quand un \gls{timenode} est exécuté, tous ses évènements (non déclenchés) sont déclenchés.} ;
    \item Les \textbf{\glspl{relationTemporelle}} lient deux \glspl{timenode} entres eux, déterminant leurs intervalles de déclenchement ;
    \item Les \textbf{processus} représente une exécution d'un processus abstrait, il sont accolés à des \glspl{relationTemporelle} dont il en prennent la durée.
\end{itemize}

Tous ces éléments sont placés sur un axe temporel avec une granularité entière. Lors de l'exécution du scénario, une variable de temps, initialisée à zéro, s'incrémente au fur et à mesure de l'écoulement du temps, c'est ce que l'on appellera l'\textbf{horloge d'exécution}.

À ces éléments de base viennent s'ajouter des éléments de plus haut niveau :
\begin{itemize}
    \item Un \gls{timenode} \startNode{}~qui est exécuté au temps zéro ;
    \item Un \gls{timenode} \finalNode{}~qui est exécuté à la fin du scénario.
\end{itemize}
Nous venons de citer les éléments de bases permettant de créer les scénarios, détaillons maintenant pas à pas les règles précises qui régissent les scénarios. Ces règles vont s'exprimer sous forme de contraintes, le CSP doit alors assurer que toutes ces contraintes soient respectées.

\subsubsection{Règles}%---------------------------------------------

\setcounter{equation}{0}
Nous appelons \textbf{date} du \gls{timenode}, la valeur de temps à laquelle une \gls{timenode} est exécuté. L'ensemble des valeurs possibles de la date d'un \gls{timenode} représente son \textbf{intervale d'exécution}.

Pour s'assurer qu'aucun évènement ne soit programmé pour être déclenché avant le début de notre scénario, nous ajoutons la contrainte suivante :

\begin{equation}
    \forall \timeNode{} \in Timenodes \setminus \{ \startNode \} : \timeNode{} >= \startNode
\end{equation}
soit : la date de chaque \gls{timenode} -- \startNode~excepté -- est supérieure ou égale à la date du \startNode.

De la même manière, nous allons nous assurer qu'aucun évènement ne puisse être déclenché après la fin du scénario.

\begin{equation}
    \forall \timeNode{} \in Timenodes \setminus \{ \startNode; \finalNode \} : \timeNode{} <= \finalNode
\end{equation}

soit : la date de chaque \gls{timenode} -- \startNode~et \finalNode~exceptés -- et inférieur à la date du \finalNode.

Pour la suite, explicitons ce qu'est une \gls{relationTemporelle} :

Une \gls{relationTemporelle} \contrainte{1} lie un \gls{timenode} \timeNode{1} prédécesseur et un \gls{timenode} \timeNode{2} successeur par une durée nominale \dureeNominale{1}, une souplesse en amont \souplesseAvant{1} et une souplesse en aval \souplesseApres{1}
\begin{itemize}
    \item La durée nominale est définie telle que : $ \dureeNominale{1} \in \left [ O ... +\infty \right [ $
    \item La souplesse en amont \souplesseAvant{1} est définie tel que : $ 0 \leq \souplesseAvant{1} $
    \item La souplesse en aval \souplesseApres{1} est définie tel que : $ 0 \leq \souplesseApres{1} $
\end{itemize}

Pour simplifier certains calculs, on utilisera les valeurs de butée min et max :
\begin{itemize}
    \item La butée minimum calculée telle que : $ \buteeMin{1} = \dureeNominale{1} - \souplesseAvant{1} $
    \item La butée maximum calculée telle que : $ \buteeMax{1} = \dureeNominale{1} + \souplesseApres{1} $
\end{itemize}

Ces intervalles sont montrés visuellement sur la figure \ref{figNotations}.

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{composants2}
    \caption{La représentation graphique utilisée : (a) \gls{timenode}, (b) contrainte, (c) durée nominale, (d) souplesse amont, (e) souplesse aval, (f) butée minimum, (g) butée maximum, (h) contrainte avec souplesse aval infinie, (i) contrainte avec souplesse aval nulle et et souplesse amont au maximum. \label{figNotations}}
\end{figure}

Nous voulons que l'intervalle de déclenchement d'un \gls{timenode} dépende des contraintes qui le précèdent, nous avons donc la contrainte suivante : 

\begin{gather*}
    \forall \contrainte{}~reliant~\timeNode{1}~a~\timeNode{2}~:\\
    \timeNode{1} + \buteeMin{1} \leq \timeNode{2}\\
    \timeNode{2} \leq \timeNode{1} + \buteeMax{1}
\end{gather*}

\subsubsection{Assurer la faisabilité du scénario}

Pour vérifier la faisabilité du scénario, on peut voir plusieurs approches (cf figure \ref{figPackages}) :
\begin{enumerate}
    \item En entrée du CSP sont fournis les contraintes et on confronte les valeurs des timenodes donnés et l'on retourne true si la configuration est valide ;
    \item En entrée du CSP sont fournis uniquement les contraintes et l'on retourne true si la configuration est valide ;
    \item En entrée du CSP ne sont fournis que les contraintes et sont retournées les valeurs des timenodes si la configuration est valide.
\end{enumerate}

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{package}
    \caption{Les différentes approches. (a) : première approche ; (b) deuxième approche ; (b) troisième approche \label{figPackages}}
\end{figure}

La première approche amène une solution triviale car la question posée est : \emph{est-ce que cette solution est valide?} Il suffit de confronter individuellement chaque contrainte aux valeurs de ses timenodes attachés, on pourra indiquer les contraintes violées.

La deuxième approche consiste à répondre à la question : \emph{est-ce qu'une solution existe ?}

La troisième approche est la plus complexe mais sans doute la plus intéressante car elle consiste à répondre à : \emph{Si cela est possible, donne moi une solution ?} Ce problème est le plus complexe et demande de proposer des critères à minimiser et/ou de permettre à l'utilisateur de les définir. 

Je pense qu'il est possible de combiner les avantages de toutes ses approches en une seule qui est la suivante (cf figure \ref{figPackages2}) :
On fournit toutes les contraintes ainsi qu'un nombre quelconque de dates, et on peut alors demander au système de calculer une solution optimale s'il en existe plusieurs, soit la solution unique, ou bien simplement lui demander si l'équation est valide.

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{package2}
    \caption{L'approche alternative \label{figPackages2}}
\end{figure}

\subsubsection{Comportement}

% pour le scénario c1, est il logique d'associer de contrainte de durée nominale différentes à un même timenode?

Pour ce faire, je vais proposer des scénarios d'utilisations pour illustrer les comportements attendus, cela va m'orienter vers un formalisme qui se voudra le plus simple possible.

\begin{figure}[ht]
    \centering
    \illustrationKeepDim{diagrammeDeploiment}
    \caption{ Déploiement logiciel de la solution.\label{figDeploiement}}
\end{figure}

Pour guider ma démarche je suivrai les principes suivants :
\begin{itemize}
    \item Réduire le nombre de règles/éléments au minimum pour faciliter la démontrabilité et les manipulations, quitte à devoir ajouter du sucre ;
    \item Autoriser un maximum les interactions\footnote{User doit être bloqué au minimum sur les contrôles normalement disponibles.} ;
    \item Le positionnement des éléments est cohérent par rapport à l'éxécution du scénario et non à des préférences visuelles\footnote{L'affichage du scénario doit correspondre avec une réalité temporelle, il ne devrait pas y avoir plusieurs moyens de l'afficher (mis à part peut-être sur l'axe des Y)} ;
    \item Interdire les actions incohérentes, quitte à informer l'utilisateur de ses "erreurs" ;
    \item Les intervalles de temps sont des informations essentielles à l'execution du scénario .
    %\item Pour fournir des solutions on gardera en tête le comportement à l'exécution\footnote{Cela nous oriente pour choisir les critères à minimiser/maximiser pour obtenir des solutions optimales} .
\end{itemize}

\subsection{souplesse d'édition}
Ce stage est l'occasion d'apporter une nouvelle réflexion sur l'outil. Il reste des questions en suspens quant au comportement désiré de l'application lors de l'édition de scénarios interactifs\footnote{par exemple interdit-t-on de créer des situations impossible lors de l'édition?}.


Ces informations sont pourtant essentielles pour définir le rôle du CSP et je vais donc me pencher dessus en essayant une analogie avec la programmation de logiciels.

Dans le but de définir les rôles du \csp{}


La création de scénarios interactifs possède des similarités avec le développement logiciel, il s'agit de décrire un comportement d'exécution.

\emph{Quelle est la souplesse d'édition dans le cas du développement logiciel?}

Dans le cas du développement classique\footnote{Écriture de code source sous forme de texte, puis compilation.}, la souplesse à l'édition est totale. J'entends par là que l'on est autorisé à passer par des états non valides pendant le processus de développement. Cela est d'ailleurs indispensable car il n'est pas concevable pour un humain d'écrire à plusieurs endroits à la fois des éléments syntaxiques complets.

Ceci n'est d'ailleurs pas un problème car avant de pouvoir être exécuté le code va passer par une étape de validation et de compilation\footnote{Pour les langages interprétés, on validera simplement l'intégrité du code fourni, dans la plupart des cas.}, où tout code non valide est rejeté.

%De plus, un code valide peut indiquer des avertissements, %TODO: expliciter

Ceci étant, avec un langage graphique nous pouvons très bien passer d'un état valide à un état valide sans passer par un état invalide, c'est ce qui est fait en général.%TODO: ref a d'autre langage graphique et le contre-exemple xcode



\subsection{Détecter les dépendances de souplesse}

Une dépendance de souplesse et une contrainte souple fortement liée à un autre contrainte souple la précédant, dans un tel cas la première contrainte ne pourra pas être déclenchée manuellement (sauf jeton passif sur l'autre).


En ce qui concerne la propagation des contraintes, il reste des choses à préciser :
dans quel but?
quelle contrainte?
le min des max est-il plus pertinent que le max des max?
trouver un cas concret?

\section{Contraintes pour l'exécution}

\subsection{Comportement}%---------------------------------------------


L'étude du système d'exécution à révélé des failles, c'est à dire que des cas considérés valides(schema3) peuvent résulter en des exécutions incorrectes.
 Actuellement, le moteur exécute une machine à État qui est créé à partir d'un système d'automates temporisés(schema4). Actuellement la traduction depuis le scénario vers les automates se fait de façon directe à partir des relations temporelles présentes.  avant de continuer considérons la représentations suivantes pour les scénarios :
On considère les scénarios comme un grahe(TODO : graphe fig 2) avec des noeud représentant les \glspl{timenode} et les arrêtes représentant des contraintes. Ce graphe est non orienté car non avons vus qu'une contrainte situé en aval peut impacter celles en amont.
Maintenant, si nous voulons représenter le scénario par des graphes après traduction vers des automates nous devons en revanche orienter les arrêtes(schema5) car ces automates n'intègre pas de relation de causalité avec des éléments futurs.  le CSP n'ayans pas de problème pour résoudre ce genre de cas une des solutions pourrait être de de faire appel à celui-ci au monde exécution,  plusieurs problèmes se posent :  la première est qu'actuellement la seule étape sur laquelle nous avons un contrôle est l'étape de traduction qui est préalable à l'exécution nous ne contrôlons pas l'exécution ; le second est la complexité des algorithmes qu'ils font tourner le CSP cela rend l'exécution temps réel très difficile voire impossible.

Ceci étant, il n'est pas du tout exclu que le moteur fasse appelle le CSP lors de la phase de traduction où la problématique de temps réel ne se pose pas.

Une approche consiste alors à modéliser le fonctionnement des automates avec un système de contraintes adapté. Il en résultera un modèle(TODO: ref shema 1) qui, s'il est valide, assure le bon déroulement du scénario avec les automates. Les questions suivantes se posent: comment exprimer les contraintes des automates, et comment modifier les scénario non valides pour les rendre valides. Faire cette traduction nous permet de garantir un fonctionnement sans erreur car c'est précisément le problème que l'on exprime.

Concernant les modifications à apporter, il y à beaucoup de solutions, mais mettons nous d'accord sur les objectifs : 
\begin{itemize}
\item le comportement du scénario lors de l'exécution doit être strictement conforme au spécification OSSIA vis-à-vis du modèle d'origine ;
\item le nombre d'éléments (automates) ajoutés doit être minimal.
\end{itemize}
