\chapter*{Introduction}

Les applications multimédias interactives forment un domaine vaste, on y retrouve un nombre croissant de performances artistiques avec des créateurs désireux d'exploiter le potentiel technologique (informatique) actuel pour étendre le champ des possibles.

Aujourd'hui de telles applications utilisent couramment des logiciels de programmation graphique tels Max/MSP ou Pure Data. Ces outils sont très puissants et ont un pouvoir d'expression quasi illimité.
Ces logiciels utilisent une approche -- que l'on appellera approche logique -- qui consiste à créer des patchs contenant des séries d'instructions, seulement, ces patchs sont organisés sur un plan et sont tous déclenchables à n'importe quel instant \figureRef{schemaLogique}.

\schema{schemaLogique}{L'approche logique de la conception d'application interactive, les action ne sont pas organisée de manière temporelle.}

Cette approche les rends peu adroits pour hiérarchiser temporellement des évènements. Les séquenceurs, de leurs cotés -- très utilisés pour la composition musicale -- ne laissent presque aucune marge de manoeuvre pour interagir avec le système lors de l'exécution de la performance.

De cette problématique est né le projet ANR \ossia{} -- Open Scenario System for Interactive Application --, il s'intéresse à l'écriture, et l'exécution de scénarios "multimédias" temporels interactifs. Ces scénarios permettent de décrire, de manière plus ou moins ouverte, le déroulement de la performance au cours du temps, ce qui rend plus naturel la composition de performances principalement temporelles (cf. figure \ref{schemaComplexite})

\schema{schemaComplexite}{L'effort à fournir pour créer des applications multimédias interactives en fonction de la nature de la performance.}

Ces scénarios peuvent être vus comme une séquence d'évènements à réaliser au cours du temps (cf. figure \ref{schemaTemporel}), tel une partition de musique, dont certains peuvent être déclenchés manuellement au moment jugé le plus opportun.

\schema{schemaTemporel}{L'approche temporelle des scénario interactif permet de décrire la hiérarchie des évènements au cours du temps.}

Le logiciel \iscore{}, développé par \ossia{}, implémente le concept de scénario interactifs et fournit une interface d'édition ainsi qu'un moteur d'exécution. Une version 0.2 d'\iscore{} existe déjà et la version 0.3 est actuellement en cours de développement, c'est dans le cadre de l'élaboration cette dernière version que s'inscrit mon stage. 



Une solution logicielle est en cours de développement, elle est composée de plusieurs éléments : score qui permet d'exécuter des scénarios interactifs, et \iscore{} qui propose une interface d'édition et de visualisation de scénario. Cette solution s'appuie sur la technologie OSC pour contrôler des modules extérieurs. La brique de base pour composer des scénarios avec i-score est la relation temporelle, elle relie entre eux les évènements pour dicter le déroulement de l'exécution.

%TODO: bouger ce passage
%Une des forces du groupe OSSIA est d'être composé d'une part importante d'artiste et d'utilisateurs finaux, permettant de centrer la création d' I-score sur les besoins des utilisateurs.

%I-score
%préciser utilisation d'iscore par compositeur ou autres pour spectacles etc...

\section*{Problématique}

Au sein de cet environnement (cf. figure \ref{figDeploiement}) il est primordial de contrôler l'intégrité des scénarios. Contrôler l'intégrité des scénarios veut dire vérifier que les relations temporelles placés dans un scénario sont exécutables, par exemple si je dis que qu'un évènement A doit se dérouler strictement après un évènement B et que B doit se dérouler strictement après A, alors il est impossible d'exécuter ce scénario.

Pour s'en assurer on peut concevoir des algorithmes ad-hoc qui lors de la composition préviennent ce genre de cas, cette solution s'offre néanmoins de plusieurs problèmes. Le premier souci est de s'assurer du bon fonctionnement de l'algorithme, la seconde chose qu'une telle solution sera difficilement évolutive ce qui est gênant quant au caractère expérimental d'\iscore{} et l'objectif de recherche du groupe \ossia{}.

Une solution considérée est d'utiliser la programmation par contrainte. L'utilisation d'un resolveur (solver) de contrainte ou solver de \acrshort{csp}, que je suis amené à élaborer lors de ce stage, permettra de répondre de façon fiable aux questions de validation mais également (de par son caractère déclaratif) de faciliter la modification du comportement d'\iscore{}.

\emph{Note : par abus de language, nous appelerons par la suite \csp{} le solveur de contrainte en lui-même.}

Ma mission est de formaliser les éléments scénaristiques ainsi que leur comportement exacte attendu, élaborer des modèles de contraintes correspondant, déterminer le ou les rôles du \csp{} au sein du fonctionnement du logiciel et ensuite implémenter les solutions à mettre en oeuvre les solutions pour les implémentant proposés.


%---------- Vocabulaire
\printglossary[type=\acronymtype]
 
\printglossary